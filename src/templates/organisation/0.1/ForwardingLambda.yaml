AWSTemplateFormatVersion: "2010-09-09"
Description: "Lambda function for forwarding CloudWatch Alarms to Email via SNS"

Parameters:
  EmailRecipient:
    Type: String
    Description: "Email address to receive alarm notifications"
  LogGroupName:
    Type: String
    Description: "Name of the CloudWatch Log Group"

Conditions:
  HasEmail: !Not [!Equals [!Ref EmailRecipient, ""]]

Resources:
  # SNS Topic for alarm notifications
  AlarmNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: "Cloudwatcher-AlarmNotifications"
      DisplayName: "CloudWatch Alarm Notifications"

  # Email Subscription
  # Additional emails can be added manually via SNS Console after deployment
  EmailSubscription:
    Type: AWS::SNS::Subscription
    Condition: HasEmail
    Properties:
      Protocol: email
      TopicArn: !Ref AlarmNotificationTopic
      Endpoint: !Ref EmailRecipient

  LambdaInvokePermissionForCloudWatch:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !GetAtt ForwardingLambda.Arn
      Principal: "lambda.alarms.cloudwatch.amazonaws.com"
      SourceArn: !Sub "arn:aws:cloudwatch:${AWS::Region}:${AWS::AccountId}:alarm:*"

  ForwardingLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/Cloudwatcher-ForwardingLambda"
      RetentionInDays: 14

  ForwardingLambda:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: "index.handler"
      FunctionName: !Sub "Cloudwatcher-ForwardingLambda"
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: nodejs20.x
      Timeout: 60
      Code:
        ZipFile: |
          const { SNSClient, PublishCommand } = require('@aws-sdk/client-sns');
          const { CloudWatchLogsClient, FilterLogEventsCommand } = require('@aws-sdk/client-cloudwatch-logs');
          const { OrganizationsClient, DescribeAccountCommand } = require('@aws-sdk/client-organizations');

          // Get account name from AWS Organizations
          async function getAccountName(accountId) {
            try {
              const orgClient = new OrganizationsClient({ region: 'us-east-1' }); // Organizations is global
              const command = new DescribeAccountCommand({ AccountId: accountId });
              const response = await orgClient.send(command);
              return response.Account?.Name || accountId;
            } catch (error) {
              console.log('Error fetching account name:', error.message);
              return accountId; // Fallback to account ID if error
            }
          }

          // Resolve user ARN to friendly name by parsing the ARN
          // Works across accounts in AWS Organizations without needing cross-account IAM permissions
          function resolveUserIdentity(userIdentity) {
            if (!userIdentity) return 'N/A';
            
            // If we already have a userName, use it
            if (userIdentity.userName) {
              return userIdentity.userName;
            }
            
            // Extract from ARN
            const arn = userIdentity.arn;
            if (!arn) {
              return userIdentity.principalId || 'N/A';
            }
            
            // Parse ARN to extract user/role name
            // Format: arn:aws:iam::123456789012:user/username or arn:aws:iam::123456789012:role/rolename
            // Also handles: arn:aws:sts::123456789012:assumed-role/rolename/session
            const match = arn.match(/:(user|role|assumed-role)\/([^/]+)/);
            if (match) {
              const [, resourceType, resourceName] = match;
              if (resourceType === 'assumed-role') {
                return `${resourceName} (AssumedRole)`;
              } else if (resourceType === 'role') {
                return `${resourceName} (Role)`;
              }
              return resourceName; // user
            }
            
            // Fallback to principalId if ARN parsing fails
            return userIdentity.principalId || 'N/A';
          }

          // Format log entry as readable plain text
          function formatLogEntry(log, index) {
            const timestamp = new Date(log.eventTime).toISOString().replace('T', ' ').substring(0, 19);
            
            // For SSO events, always show N/A - check eventSource directly (most reliable)
            const userName = log.eventSource === 'sso.amazonaws.com' 
              ? 'N/A (SSO)' 
              : resolveUserIdentity(log.userIdentity);
            
            const lines = [
              `[${index + 1}] ${timestamp} UTC`,
              `    Event:      ${log.eventName || 'N/A'}`,
              `    User:       ${userName}`,
              `    Source IP:  ${log.sourceIPAddress || 'N/A'}`,
            ];
            
            if (log.errorCode) {
              lines.push(`    Error:      ${log.errorCode}`);
            }
            if (log.errorMessage) {
              lines.push(`    Message:    ${log.errorMessage}`);
            }
            if (log.requestParameters) {
              lines.push(`    Request:    ${JSON.stringify(log.requestParameters).substring(0, 100)}`);
            }
            
            return lines.join('\n');
          }

          // Format complete email message
          function formatEmailMessage(alarmData, cloudwatchLogEntries, accountName, accountId, displayName) {
            const alarmState = alarmData.state.value;
            const prevState = alarmData.previousState.value;
            const alarmName = alarmData.alarmName;
            const timestamp = new Date(alarmData.state.timestamp).toISOString().replace('T', ' ').substring(0, 19);
            
            const statusEmoji = alarmState === 'ALARM' ? 'ðŸš¨' : 'âœ…';
            const separator = 'â•'.repeat(40);
            const divider = 'â”€'.repeat(40);
            
            let message = [
              separator,
              `${statusEmoji} CloudWatch Alarm: ${displayName || alarmName}`,
              separator,
              '',
              `Status:     ${prevState} â†’ ${alarmState}`,
              `Timestamp:  ${timestamp} UTC`,
              `Account:    ${accountName} (${accountId})`,
              '',
              divider,
              `ðŸ“‹ CloudWatch Log Entries (${cloudwatchLogEntries.length} found)`,
              divider,
              ''
            ];
            
            // Add formatted log entries
            cloudwatchLogEntries.forEach((log, index) => {
              message.push(formatLogEntry(log, index));
              message.push('');
            });
            
            // Add raw event data for debugging
            message.push(divider);
            message.push('ðŸ” Raw Event Data (Debug)');
            message.push(divider);
            message.push('');
            cloudwatchLogEntries.forEach((log, index) => {
              message.push(`[${index + 1}] Raw CloudTrail Event:`);
              message.push(JSON.stringify(log, null, 2));
              message.push('');
            });
            
            message.push(divider);
            message.push('Generated by Cloudwatcher');
            message.push(separator);
            
            return message.join('\n');
          }

          exports.handler = async (event) => {
            const alarmState = event.alarmData.state.value;
            const prevState = event.alarmData.previousState.value;
            console.log('alarmState', alarmState, prevState);
            
            // Skip notification if alarm is resolving (ALARM â†’ OK)
            // For security events, we only care when something suspicious happens, not when it stops
            if (alarmState !== "ALARM" && prevState === "ALARM") {
              console.log('Alarm resolved, skipping notification');
              return;
            }
            
            const snsClient = new SNSClient({ region: process.env.AWS_REGION });
            const cloudWatchLogsClient = new CloudWatchLogsClient({ region: process.env.AWS_REGION });
            const reasonData = JSON.parse(event.alarmData.state.reasonData || '{}');
            const previousReasonData = JSON.parse(event.alarmData.previousState.reasonData || '{}');
            const logGroupName = process.env.LOG_GROUP_NAME;

            const alarmName = event.alarmData.alarmName;
            console.log('alarmName', event.alarmData);  
            const [prefix, rawEventName] = alarmName.split(':'); 
            if(!rawEventName){
              // TODO prefix with CS:CIS1.2:iam:AccessDeniedAlarm
              return;
            }
            
            const eventName = rawEventName.replace(/Alarm$/, ''); 

            const eventSourceMapping = {
              iam: "iam.amazonaws.com",
              sts: "sts.amazonaws.com",
              sso: "sso.amazonaws.com"
            };

            const serviceDisplayNames = {
              iam: "IAM",
              sts: "Login (STS)",
              sso: "SSO"
            };

            const startTime = new Date(reasonData.startDate).getTime();
            const endTime = new Date(event.alarmData.state.timestamp).getTime(); 
            
            let filterFieldKey = "eventName";
            let filterFieldValue = eventName;
            
            if(eventName.includes('_')){
              [filterFieldKey, filterFieldValue] = eventName.split('_');
            }

            const filterPattern = `{ ($.eventSource = "${eventSourceMapping[prefix]}") && ($.${filterFieldKey} = "${filterFieldValue}") }`;
            const logParams = {logGroupName, startTime, endTime, filterPattern, limit: 500}; 
            console.log('logParams', logParams);

            const logCommand = new FilterLogEventsCommand(logParams);
            const logData = await cloudWatchLogsClient.send(logCommand);
            let cloudwatchLogEntries = logData.events.map(logEvent => JSON.parse(logEvent.message));
            console.log('cloudwatchLogEntries', cloudwatchLogEntries);

            if(cloudwatchLogEntries.length === 0){
              console.log('alarmName', alarmName, cloudwatchLogEntries.length);  
              return;
            }

            // Get account ID from the actual log entry (where the error occurred)
            // instead of the central CloudTrail account
            const accountId = cloudwatchLogEntries[0]?.recipientAccountId || 
                             cloudwatchLogEntries[0]?.userIdentity?.accountId || 
                             event.alarmData.configuration?.accountId || 
                             event.accountId || 
                             process.env.AWS_ACCOUNT_ID;
            const accountName = await getAccountName(accountId);
            console.log('Account:', accountName, accountId);

            // Create display name for better readability
            const serviceDisplayName = serviceDisplayNames[prefix] || prefix.toUpperCase();
            const displayName = `${serviceDisplayName}: ${eventName}`;

            // Format and send email via SNS
            const emailMessage = formatEmailMessage(event.alarmData, cloudwatchLogEntries, accountName, accountId, displayName);
            const subject = `${alarmState === 'ALARM' ? 'ðŸš¨' : 'âœ…'} CloudWatch Alert: ${displayName}`;
            
            const params = {
              TopicArn: process.env.SNS_TOPIC_ARN,
              Subject: subject,
              Message: emailMessage,
            };
            
            const command = new PublishCommand(params);
            try {
              await snsClient.send(command);
              console.log('Email notification sent successfully');
            } catch(e) {
              console.log('Error sending SNS notification', e);
            }
          };
      Environment:
        Variables:
          LOG_GROUP_NAME: !Ref LogGroupName
          SNS_TOPIC_ARN: !Ref AlarmNotificationTopic

  # IAM Role for the Lambda function to publish to SNS and read CloudWatch Logs
  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: "LambdaSNSPublishPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "sns:Publish"
                  - "logs:FilterLogEvents"
                Resource:
                  - !Ref AlarmNotificationTopic
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${LogGroupName}"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${LogGroupName}:log-stream:*"
              - Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/Cloudwatcher-ForwardingLambda:*"
              - Effect: Allow
                Action:
                  - "organizations:DescribeAccount"
                Resource: "*"

Outputs:
  ForwardingLambdaArn:
    Description: "ARN of the Forwarding Lambda function"
    Value: !GetAtt ForwardingLambda.Arn
  
  SNSTopicArn:
    Description: "ARN of the SNS Topic for alarm notifications"
    Value: !Ref AlarmNotificationTopic
  
  EmailSubscriptionNote:
    Description: "Important: Check your email inbox and confirm the SNS subscription"
    Value: !Sub "Confirmation emails have been sent to all recipients. Please confirm to receive alerts."
